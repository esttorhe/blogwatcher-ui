---
phase: 03-article-display
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/model/model.go
  - internal/storage/database.go
  - internal/server/server.go
  - internal/server/template_funcs.go
autonomous: true

must_haves:
  truths:
    - "timeAgo function converts time.Time to human-readable relative string"
    - "faviconURL function extracts domain and builds Google S2 URL"
    - "ArticleWithBlog struct includes BlogName and BlogURL from JOIN"
    - "ListArticlesWithBlog returns articles with blog metadata"
  artifacts:
    - path: "internal/server/template_funcs.go"
      provides: "timeAgo and faviconURL template functions"
      min_lines: 50
    - path: "internal/model/model.go"
      provides: "ArticleWithBlog struct"
      contains: "ArticleWithBlog"
    - path: "internal/storage/database.go"
      provides: "ListArticlesWithBlog method"
      contains: "ListArticlesWithBlog"
  key_links:
    - from: "internal/server/server.go"
      to: "template.FuncMap"
      via: "Funcs() call BEFORE ParseGlob()"
      pattern: "Funcs.*timeAgo"
    - from: "internal/storage/database.go"
      to: "model.ArticleWithBlog"
      via: "SQL JOIN with scan"
      pattern: "INNER JOIN blogs"
---

<objective>
Create template functions and database infrastructure for article cards with rich metadata.

Purpose: Phase 3 requires displaying article cards with relative timestamps ("7 hours ago"), blog names, and favicons. This plan establishes the backend foundation: template functions for time formatting and favicon URLs, the ArticleWithBlog model combining article and blog data, and a database query using JOIN to fetch both together.

Output:
- Template functions: timeAgo (relative time) and faviconURL (Google S2 API)
- ArticleWithBlog model with BlogName and BlogURL fields
- ListArticlesWithBlog database method returning joined data
</objective>

<execution_context>
@/Users/esteban.torres/.claude/get-shit-done/workflows/execute-plan.md
@/Users/esteban.torres/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-article-display/03-RESEARCH.md
@internal/server/server.go
@internal/model/model.go
@internal/storage/database.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ArticleWithBlog model and ListArticlesWithBlog database method</name>
  <files>internal/model/model.go, internal/storage/database.go</files>
  <action>
1. In internal/model/model.go, add ArticleWithBlog struct after the existing Article struct:
   - Include all Article fields: ID, BlogID, Title, URL, PublishedDate, DiscoveredDate, IsRead
   - Add BlogName string field
   - Add BlogURL string field

2. In internal/storage/database.go, add ListArticlesWithBlog method:
   - Signature: (db *Database) ListArticlesWithBlog(isRead bool, blogID *int64) ([]model.ArticleWithBlog, error)
   - SQL query using INNER JOIN blogs b ON a.blog_id = b.id
   - SELECT columns: a.id, a.blog_id, a.title, a.url, a.published_date, a.discovered_date, a.is_read, b.name, b.url
   - WHERE a.is_read = ? with optional AND a.blog_id = ? filter
   - ORDER BY a.discovered_date DESC
   - Scan into ArticleWithBlog struct using existing parseTime helper for dates

Note: Keep the existing ListArticlesByReadStatus method - it's still used elsewhere. The new method is specifically for article display with blog metadata.
  </action>
  <verify>
Run `go build ./...` to confirm no compilation errors.
Run `go vet ./...` to check for issues.
  </verify>
  <done>
ArticleWithBlog struct exists with BlogName and BlogURL fields.
ListArticlesWithBlog method compiles and follows same patterns as existing ListArticlesByReadStatus.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create template functions file with timeAgo and faviconURL</name>
  <files>internal/server/template_funcs.go</files>
  <action>
Create new file internal/server/template_funcs.go with:

1. ABOUTME comments: "Defines custom template functions for HTML rendering."
   "Contains timeAgo for relative time and faviconURL for blog favicons."

2. Package declaration: package server

3. Imports: "fmt", "net/url", "time"

4. timeAgo function:
   - Signature: func timeAgo(t *time.Time) string
   - Handle nil input by returning empty string ""
   - Calculate diff := time.Now().Sub(*t)
   - Handle negative diff (future times) by returning "in the future"
   - Return human-readable strings based on duration:
     * < 60 seconds: "just now"
     * < 60 minutes: "N minutes ago" (or "1 minute ago" for singular)
     * < 24 hours: "N hours ago" (or "1 hour ago")
     * < 7 days: "yesterday" or "N days ago"
     * < 5 weeks: "1 week ago" or "N weeks ago"
     * < 12 months: "1 month ago" or "N months ago"
     * else: "1 year ago" or "N years ago"

5. faviconURL function:
   - Signature: func faviconURL(blogURL string) string
   - Parse URL using url.Parse
   - If parse error or empty host, return empty string ""
   - Return fmt.Sprintf("https://www.google.com/s2/favicons?domain=%s&sz=32", u.Host)
  </action>
  <verify>
Run `go build ./...` to confirm no compilation errors.
Run `go vet ./...` to check for issues.
  </verify>
  <done>
template_funcs.go exists with timeAgo and faviconURL functions.
Both functions handle edge cases (nil time, invalid URL).
  </done>
</task>

<task type="auto">
  <name>Task 3: Register FuncMap in server.go BEFORE template parsing</name>
  <files>internal/server/server.go</files>
  <action>
Modify NewServer function in internal/server/server.go:

1. Add "html/template" is already imported - verify FuncMap is accessible

2. Before the existing `tmpl := template.New("")` line, create FuncMap:
   ```go
   funcMap := template.FuncMap{
       "timeAgo":    timeAgo,
       "faviconURL": faviconURL,
   }
   ```

3. Modify the template.New line to include Funcs():
   ```go
   tmpl := template.New("").Funcs(funcMap)
   ```

CRITICAL: The Funcs() call MUST be BEFORE any ParseGlob() calls. If FuncMap is added after parsing, templates cannot use the functions.

4. The rest of the template parsing (ParseGlob calls) remains unchanged.
  </action>
  <verify>
Run `go build ./...` to confirm template functions are registered correctly.
Run `go run main.go` briefly and verify server starts without template errors.
  </verify>
  <done>
FuncMap with timeAgo and faviconURL is registered before template parsing.
Server starts successfully with no "undefined function" errors.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds with no errors
2. `go vet ./...` reports no issues
3. `go run main.go` starts server without template parsing errors
4. Code review: FuncMap.Funcs() appears BEFORE first ParseGlob() call
5. Code review: ListArticlesWithBlog uses INNER JOIN with blogs table
</verification>

<success_criteria>
- ArticleWithBlog struct exists with BlogName and BlogURL fields
- ListArticlesWithBlog returns articles with blog metadata from JOIN query
- timeAgo handles nil, returns relative time strings ("7 hours ago")
- faviconURL returns Google S2 URL or empty string for invalid URLs
- Template functions registered in server.go before parsing
- All Go code compiles and passes vet
</success_criteria>

<output>
After completion, create `.planning/phases/03-article-display/03-01-SUMMARY.md`
</output>
