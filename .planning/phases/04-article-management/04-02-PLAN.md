---
phase: 04-article-management
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - internal/storage/database.go
  - internal/server/handlers.go
  - internal/server/routes.go
  - templates/partials/article-list.gohtml
  - static/styles.css
autonomous: false

must_haves:
  truths:
    - "User can click 'Read' button on article card and see it disappear from Inbox"
    - "User can click 'Unread' button on article card and see it disappear from Archived"
    - "User can click 'Mark all read' and see all visible articles move to Archived"
    - "User can click 'Sync' and see new articles appear after blogs are scanned"
    - "Read/unread state persists to database"
  artifacts:
    - path: "internal/storage/database.go"
      provides: "Bulk mark all unread as read"
      contains: "func (db *Database) MarkAllUnreadArticlesRead"
    - path: "internal/server/handlers.go"
      provides: "POST handlers for article management"
      exports: ["handleMarkRead", "handleMarkUnread", "handleMarkAllRead", "handleSync"]
    - path: "internal/server/routes.go"
      provides: "POST route registration"
      contains: "POST /articles/{id}/read"
    - path: "templates/partials/article-list.gohtml"
      provides: "Article cards with action buttons and toolbar"
      contains: "hx-post"
    - path: "static/styles.css"
      provides: "Action button and toolbar styling"
      contains: ".action-btn"
  key_links:
    - from: "templates/partials/article-list.gohtml"
      to: "/articles/{id}/read"
      via: "HTMX hx-post attribute"
      pattern: "hx-post=\"/articles/{{.ID}}/read\""
    - from: "internal/server/handlers.go"
      to: "internal/storage/database.go"
      via: "database method calls"
      pattern: "s\\.db\\.MarkArticleRead|s\\.db\\.MarkAllUnreadArticlesRead"
    - from: "internal/server/handlers.go"
      to: "internal/scanner/scanner.go"
      via: "scanner function call"
      pattern: "scanner\\.ScanAllBlogs"
---

<objective>
Implement article management UI and handlers for marking articles read/unread, bulk mark all read, and blog synchronization.

Purpose: Complete MGMT-01, MGMT-02, MGMT-03, MGMT-04 requirements - the core functionality for article management.

Output: Working mark read/unread buttons on article cards, toolbar with "Mark all read" and "Sync" buttons, all wired to POST handlers that update database and return refreshed UI.
</objective>

<execution_context>
@/Users/esteban.torres/.claude/get-shit-done/workflows/execute-plan.md
@/Users/esteban.torres/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-article-management/04-RESEARCH.md

# Prior plan summary needed for scanner integration
@.planning/phases/04-article-management/04-01-SUMMARY.md

# Existing files to modify
@internal/storage/database.go
@internal/server/handlers.go
@internal/server/routes.go
@templates/partials/article-list.gohtml
@static/styles.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bulk mark read database method and POST handlers</name>
  <files>
    internal/storage/database.go
    internal/server/handlers.go
  </files>
  <action>
**In internal/storage/database.go**, add:

```go
// MarkAllUnreadArticlesRead marks all unread articles as read.
// If blogID is provided, only marks articles from that blog.
func (db *Database) MarkAllUnreadArticlesRead(blogID *int64) error {
    query := `UPDATE articles SET is_read = 1 WHERE is_read = 0`
    var args []interface{}

    if blogID != nil {
        query += " AND blog_id = ?"
        args = append(args, *blogID)
    }

    _, err := db.conn.Exec(query, args...)
    return err
}
```

**In internal/server/handlers.go**, add these handlers:

1. handleMarkRead(w http.ResponseWriter, r *http.Request)
   - Parse article ID from r.PathValue("id") using Go 1.22+ routing
   - Call s.db.MarkArticleRead(id)
   - Return 200 OK with empty body (HTMX will remove the card via outerHTML swap)
   - Return 404 if article not found, 400 if invalid ID

2. handleMarkUnread(w http.ResponseWriter, r *http.Request)
   - Same pattern as handleMarkRead
   - Call s.db.MarkArticleUnread(id)
   - Return 200 OK with empty body

3. handleMarkAllRead(w http.ResponseWriter, r *http.Request)
   - Parse form to get optional "blog" parameter for filtering
   - Call s.db.MarkAllUnreadArticlesRead(blogID)
   - Return refreshed article list by re-fetching and rendering article-list.gohtml
   - The list will be empty (all marked read) for inbox view

4. handleSync(w http.ResponseWriter, r *http.Request)
   - Import scanner package: "github.com/esttorhe/blogwatcher-ui/internal/scanner"
   - Call scanner.ScanAllBlogs(s.db, 1) with single worker to avoid SQLite write conflicts
   - Log results (new article counts, errors)
   - Return refreshed article list for current filter

IMPORTANT for HTMX:
- Return 200 OK, NOT 204 No Content (HTMX ignores 204)
- For mark read/unread: return empty body
- For mark all read/sync: return rendered article-list.gohtml partial
  </action>
  <verify>
Run `go build ./internal/storage/...` and `go build ./internal/server/...` - both should compile.
  </verify>
  <done>
Database has MarkAllUnreadArticlesRead method. Server has handleMarkRead, handleMarkUnread, handleMarkAllRead, handleSync handlers that compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register POST routes and update templates with action buttons</name>
  <files>
    internal/server/routes.go
    templates/partials/article-list.gohtml
    static/styles.css
  </files>
  <action>
**In internal/server/routes.go**, add POST routes in registerRoutes():

```go
// Article management actions
s.mux.HandleFunc("POST /articles/{id}/read", s.handleMarkRead)
s.mux.HandleFunc("POST /articles/{id}/unread", s.handleMarkUnread)
s.mux.HandleFunc("POST /articles/mark-all-read", s.handleMarkAllRead)

// Sync
s.mux.HandleFunc("POST /sync", s.handleSync)
```

**In templates/partials/article-list.gohtml**, update to add:

1. Toolbar at the top with "Mark all read" and "Sync" buttons:
```html
<div class="toolbar">
    <button class="btn-action"
            hx-post="/articles/mark-all-read?blog={{.CurrentBlogID}}"
            hx-target="#main-content"
            hx-swap="innerHTML"
            hx-confirm="Mark all articles as read?">
        Mark All Read
    </button>
    <button class="btn-action sync-btn"
            hx-post="/sync?filter={{.CurrentFilter}}"
            hx-target="#main-content"
            hx-swap="innerHTML">
        <span class="sync-text">Sync</span>
        <span class="htmx-indicator">Syncing...</span>
    </button>
</div>
```

2. Article card with action button - wrap in div with id for targeting:
```html
<article class="article-card" id="article-{{.ID}}">
    ...existing content...
    {{if .IsRead}}
    <button class="action-btn"
            hx-post="/articles/{{.ID}}/unread"
            hx-target="#article-{{.ID}}"
            hx-swap="outerHTML swap:300ms"
            title="Mark as unread">
        Unread
    </button>
    {{else}}
    <button class="action-btn"
            hx-post="/articles/{{.ID}}/read"
            hx-target="#article-{{.ID}}"
            hx-swap="outerHTML swap:300ms"
            title="Mark as read">
        Read
    </button>
    {{end}}
</article>
```

3. Hide toolbar when no articles (show only in article list section, not in empty state)

**In static/styles.css**, add:

```css
/* Toolbar styling */
.toolbar {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border);
}

.btn-action {
    padding: 0.5rem 1rem;
    border: 1px solid var(--border);
    border-radius: 6px;
    background-color: var(--bg-surface);
    color: var(--text-primary);
    cursor: pointer;
    font-size: 0.875rem;
    transition: background-color var(--transition-speed) ease;
}

.btn-action:hover {
    background-color: var(--bg-elevated);
}

.btn-action.htmx-request {
    pointer-events: none;
    opacity: 0.5;
}

/* Action button on article cards */
.action-btn {
    flex-shrink: 0;
    padding: 0.5rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: 4px;
    background-color: var(--bg-elevated);
    color: var(--text-primary);
    cursor: pointer;
    font-size: 0.75rem;
    transition: background-color var(--transition-speed) ease,
                opacity var(--transition-speed) ease;
}

.action-btn:hover {
    background-color: var(--accent);
    color: var(--bg-primary);
}

.action-btn.htmx-request {
    pointer-events: none;
    opacity: 0.5;
}

/* Fade out animation for removed cards */
.article-card.htmx-swapping {
    opacity: 0;
    transition: opacity 300ms ease-out;
}

/* Loading indicator */
.htmx-indicator {
    display: none;
}

.htmx-request .htmx-indicator,
.htmx-request.htmx-indicator {
    display: inline;
}

.htmx-request .sync-text {
    display: none;
}
```
  </action>
  <verify>
Run `go build ./...` - project should compile.
Start server with `go run ./cmd/server` and verify:
1. Routes are registered (check server startup logs)
2. Template renders without error
  </verify>
  <done>
POST routes registered for /articles/{id}/read, /articles/{id}/unread, /articles/mark-all-read, /sync.
Article list template has toolbar with Mark All Read and Sync buttons.
Article cards have Read/Unread action buttons.
CSS styles action buttons and loading states.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete article management functionality: mark read/unread buttons on cards, mark all read button, sync button, all wired to POST handlers</what-built>
  <how-to-verify>
1. Start server: `go run ./cmd/server`
2. Open http://localhost:8080 in browser
3. Test mark read: Click "Read" button on an article card in Inbox - article should fade out and disappear
4. Navigate to "Archived" in sidebar - the article you marked read should now appear there
5. Test mark unread: Click "Unread" button on an article in Archived - it should fade out and disappear
6. Navigate back to "Inbox" - the article should now appear there again
7. Test mark all read: Click "Mark All Read" button in toolbar - confirm dialog should appear - click OK - all articles should disappear from Inbox
8. Test sync: Click "Sync" button - should show "Syncing..." while running - new articles should appear if blogs have updates
9. Verify CLI sees same state: Run `blogwatcher list --unread` and confirm count matches UI
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. Build passes: `go build ./...`
2. Server starts without error: `go run ./cmd/server`
3. Mark read: Click button -> article fades out -> appears in Archived
4. Mark unread: Click button -> article fades out -> appears in Inbox
5. Mark all read: Click button -> confirm -> all inbox articles move to Archived
6. Sync: Click button -> loading state -> new articles appear
7. Database state matches CLI tool's view
</verification>

<success_criteria>
- MGMT-01: Individual mark read button works and persists to database
- MGMT-02: Individual mark unread button works and persists to database
- MGMT-03: Mark all read button works for bulk action
- MGMT-04: Sync button triggers scanner and shows new articles
- UI feedback: Buttons show loading state, cards animate out smoothly
- State persistence: Changes visible in CLI tool immediately
</success_criteria>

<output>
After completion, create `.planning/phases/04-article-management/04-02-SUMMARY.md`
</output>
