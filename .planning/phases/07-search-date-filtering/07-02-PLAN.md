---
phase: 07-search-date-filtering
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/server/handlers.go
  - templates/partials/article-list.gohtml
  - static/styles.css
autonomous: true

must_haves:
  truths:
    - "User can type in search box and see filtered results after 300ms"
    - "User can click Last Week and see articles from past 7 days"
    - "User can click Last Month and see articles from past 30 days"
    - "User can select custom date range with date inputs"
    - "User sees results count showing how many articles match"
    - "All filters (blog + status + search + date) combine correctly"
  artifacts:
    - path: "templates/partials/article-list.gohtml"
      provides: "Search input, date filters, results count"
      contains: "hx-trigger"
    - path: "internal/server/handlers.go"
      provides: "Handler using SearchArticles"
      contains: "SearchArticles"
    - path: "static/styles.css"
      provides: "Filter bar styling"
      contains: "filter-bar"
  key_links:
    - from: "templates/partials/article-list.gohtml"
      to: "/articles"
      via: "HTMX hx-get with debounce"
      pattern: "hx-trigger.*delay:300ms"
    - from: "internal/server/handlers.go"
      to: "db.SearchArticles"
      via: "handler calls search method"
      pattern: "SearchArticles"
    - from: "templates/partials/article-list.gohtml"
      to: "ArticleCount"
      via: "template displays count"
      pattern: "Showing.*articles"
---

<objective>
Add search input, date filters, and results count to the article list UI with full HTMX integration.

Purpose: Complete Phase 7 by wiring the FTS5 search and date filtering to a user-friendly interface with debounced search and quick date shortcuts.
Output: Search bar with 300ms debounce, Last Week/Last Month buttons, date range picker, results count display.
</objective>

<execution_context>
@/Users/esteban.torres/.claude/get-shit-done/workflows/execute-plan.md
@/Users/esteban.torres/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-search-date-filtering/07-RESEARCH.md
@.planning/phases/07-search-date-filtering/07-01-SUMMARY.md
@internal/server/handlers.go
@templates/partials/article-list.gohtml
@static/styles.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update handlers to use SearchArticles with all filter params</name>
  <files>internal/server/handlers.go</files>
  <action>
Refactor handleArticleList (and handleIndex for initial load) to use SearchArticles:

1. Parse new query parameters:
   - search: string (FTS5 query)
   - date_from: string in YYYY-MM-DD format
   - date_to: string in YYYY-MM-DD format
   - Existing: filter (unread/read), blog

2. Build model.SearchOptions:
   ```go
   opts := model.SearchOptions{
       SearchQuery: r.URL.Query().Get("search"),
   }

   // Parse status filter
   filter := r.URL.Query().Get("filter")
   if filter == "read" {
       isRead := true
       opts.IsRead = &isRead
   } else {
       isRead := false
       opts.IsRead = &isRead
       filter = "unread" // default
   }

   // Parse blog filter
   if blogParam := r.URL.Query().Get("blog"); blogParam != "" {
       if id, err := strconv.ParseInt(blogParam, 10, 64); err == nil {
           opts.BlogID = &id
       }
   }

   // Parse date filters (format: 2006-01-02)
   if dateFrom := r.URL.Query().Get("date_from"); dateFrom != "" {
       if t, err := time.Parse("2006-01-02", dateFrom); err == nil {
           opts.DateFrom = &t
       }
   }
   if dateTo := r.URL.Query().Get("date_to"); dateTo != "" {
       if t, err := time.Parse("2006-01-02", dateTo); err == nil {
           opts.DateTo = &t
       }
   }
   ```

3. Call SearchArticles and extract count:
   ```go
   articles, totalCount, err := s.db.SearchArticles(opts)
   ```

4. Add to template data:
   ```go
   data := map[string]interface{}{
       "Articles":      articles,
       "ArticleCount":  totalCount,
       "CurrentFilter": filter,
       "CurrentBlogID": currentBlogID,
       "SearchQuery":   opts.SearchQuery,
       "DateFrom":      r.URL.Query().Get("date_from"),
       "DateTo":        r.URL.Query().Get("date_to"),
   }
   ```

5. Also update handleIndex, handleMarkAllRead, and handleSync to use the same pattern so all views support the new filters consistently.
  </action>
  <verify>
```bash
cd /Users/esteban.torres/workspace/github/esttorhe/blogwatcher-ui && go build ./...
```
Then start server and test with curl:
```bash
curl -s "http://localhost:8080/articles?search=test" | head -20
```
  </verify>
  <done>
handleArticleList parses search, date_from, date_to parameters and uses SearchArticles. Template data includes ArticleCount, SearchQuery, DateFrom, DateTo. All handlers that return article lists are updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add filter bar with search input and date filters to template</name>
  <files>templates/partials/article-list.gohtml</files>
  <action>
Add a filter bar between the header and toolbar with search and date controls:

1. Add filter bar HTML after the header, before the toolbar:
   ```html
   <div class="filter-bar">
       <div class="search-container">
           <input type="search"
                  name="search"
                  id="search-input"
                  placeholder="Search articles..."
                  value="{{.SearchQuery}}"
                  hx-get="/articles"
                  hx-trigger="keyup changed delay:300ms, search"
                  hx-target="#main-content"
                  hx-include="[name='filter'],[name='blog'],[name='date_from'],[name='date_to']"
                  hx-push-url="true">
       </div>

       <div class="date-filters">
           <button type="button" class="btn-filter" onclick="setDateRange('week')">Last Week</button>
           <button type="button" class="btn-filter" onclick="setDateRange('month')">Last Month</button>
           <button type="button" class="btn-filter" onclick="clearDateRange()">All Time</button>

           <input type="date"
                  name="date_from"
                  id="date_from"
                  value="{{.DateFrom}}"
                  hx-get="/articles"
                  hx-trigger="change"
                  hx-target="#main-content"
                  hx-include="[name='filter'],[name='blog'],[name='search'],[name='date_to']"
                  hx-push-url="true">
           <span class="date-separator">to</span>
           <input type="date"
                  name="date_to"
                  id="date_to"
                  value="{{.DateTo}}"
                  hx-get="/articles"
                  hx-trigger="change"
                  hx-target="#main-content"
                  hx-include="[name='filter'],[name='blog'],[name='search'],[name='date_from']"
                  hx-push-url="true">
       </div>

       <!-- Hidden inputs to preserve current filter and blog -->
       <input type="hidden" name="filter" value="{{.CurrentFilter}}">
       {{if .CurrentBlogID}}<input type="hidden" name="blog" value="{{.CurrentBlogID}}">{{end}}
   </div>
   ```

2. Add results count display before the article list:
   ```html
   <div class="results-info">
       {{if .Articles}}
           Showing {{.ArticleCount}} article{{if ne .ArticleCount 1}}s{{end}}
       {{else}}
           No articles found
       {{end}}
   </div>
   ```

3. Add JavaScript for date range shortcuts (at end of template or in a script block):
   ```html
   <script>
   function setDateRange(range) {
       const to = new Date();
       const from = new Date();

       if (range === 'week') {
           from.setDate(to.getDate() - 7);
       } else if (range === 'month') {
           from.setMonth(to.getMonth() - 1);
       }

       document.getElementById('date_from').value = from.toISOString().split('T')[0];
       document.getElementById('date_to').value = to.toISOString().split('T')[0];

       // Trigger HTMX update via change event
       document.getElementById('date_from').dispatchEvent(new Event('change', {bubbles: true}));
   }

   function clearDateRange() {
       document.getElementById('date_from').value = '';
       document.getElementById('date_to').value = '';
       document.getElementById('date_from').dispatchEvent(new Event('change', {bubbles: true}));
   }
   </script>
   ```

Note: The hx-include selectors must match the actual input names/IDs. Use CSS selectors that work with the existing filter/blog hidden inputs.
  </action>
  <verify>
Start the server and verify in browser:
1. Navigate to http://localhost:8080
2. Confirm search input appears
3. Type in search box - should see network request after 300ms delay
4. Click "Last Week" - date inputs should populate
5. Verify results count displays
  </verify>
  <done>
Search input with debounce exists. Date filter buttons and inputs exist. Results count displays. All controls trigger HTMX requests that include all filter parameters.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add CSS styling for filter bar</name>
  <files>static/styles.css</files>
  <action>
Add responsive styles for the filter bar at the end of styles.css:

```css
/* Filter Bar */
.filter-bar {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    padding: 1rem;
    background-color: var(--surface);
    border-bottom: 1px solid var(--border);
    align-items: center;
}

.search-container {
    flex: 1;
    min-width: 200px;
}

.search-container input[type="search"] {
    width: 100%;
    padding: 0.5rem 1rem;
    border: 1px solid var(--border);
    border-radius: 0.375rem;
    background-color: var(--background);
    color: var(--text);
    font-size: 0.875rem;
}

.search-container input[type="search"]:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 2px var(--primary-alpha, rgba(59, 130, 246, 0.2));
}

.search-container input[type="search"]::placeholder {
    color: var(--text-secondary);
}

.date-filters {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: center;
}

.btn-filter {
    padding: 0.375rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: 0.375rem;
    background-color: var(--surface);
    color: var(--text);
    font-size: 0.75rem;
    cursor: pointer;
    transition: background-color 0.15s, border-color 0.15s;
}

.btn-filter:hover {
    background-color: var(--background);
    border-color: var(--primary);
}

.date-filters input[type="date"] {
    padding: 0.375rem 0.5rem;
    border: 1px solid var(--border);
    border-radius: 0.375rem;
    background-color: var(--background);
    color: var(--text);
    font-size: 0.75rem;
}

.date-filters input[type="date"]:focus {
    outline: none;
    border-color: var(--primary);
}

.date-separator {
    color: var(--text-secondary);
    font-size: 0.75rem;
}

.results-info {
    padding: 0.5rem 1rem;
    color: var(--text-secondary);
    font-size: 0.875rem;
    border-bottom: 1px solid var(--border);
}

/* Mobile responsive */
@media (max-width: 768px) {
    .filter-bar {
        flex-direction: column;
        align-items: stretch;
    }

    .search-container {
        width: 100%;
    }

    .date-filters {
        width: 100%;
        justify-content: flex-start;
    }
}
```

IMPORTANT: Verify var(--surface), var(--border), var(--background), var(--text), var(--text-secondary), var(--primary) exist in the CSS. If any are missing, use appropriate fallback colors or add the variable definitions to match existing theme.
  </action>
  <verify>
Start server and visually inspect:
1. Filter bar appears below header
2. Search input spans available width
3. Date filter buttons are properly styled
4. Responsive: on narrow viewport, elements stack vertically
5. Theme: colors match existing dark/light theme
  </verify>
  <done>
Filter bar styled with responsive layout. Search input, date buttons, and date inputs have consistent styling matching existing theme. Mobile layout stacks elements vertically.
  </done>
</task>

</tasks>

<verification>
1. Server compiles and starts: `go build ./... && ./server`
2. Search input visible and has 300ms debounce (network tab shows delay)
3. Type search term - results filter to matching titles
4. Click "Last Week" - date inputs populate with past 7 days range
5. Click "Last Month" - date inputs populate with past 30 days range
6. Click "All Time" - date inputs clear
7. Results count shows "Showing X articles" or "No articles found"
8. Combine filters: blog + status + search + date all work together
9. URL updates with all filter parameters (push-url works)
10. Refreshing page with filter params preserves the search state
</verification>

<success_criteria>
- [ ] SRCH-01: Search articles by title text works
- [ ] SRCH-02: Search input debounces at 300ms (not every keystroke)
- [ ] SRCH-03: "Last Week" button filters to past 7 days
- [ ] SRCH-04: "Last Month" button filters to past 30 days
- [ ] SRCH-05: Custom date range picker works
- [ ] SRCH-06: All filters combine correctly (blog + status + search + date)
- [ ] SRCH-07: Results count displays "Showing X articles"
- [ ] Filter bar is responsive on mobile
- [ ] Theme colors match existing dark/light modes
</success_criteria>

<output>
After completion, create `.planning/phases/07-search-date-filtering/07-02-SUMMARY.md`
</output>
