---
phase: 07-search-date-filtering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/storage/database.go
  - internal/model/model.go
autonomous: true

must_haves:
  truths:
    - "FTS5 virtual table exists and syncs with articles table"
    - "Search query against title returns matching articles"
    - "Empty search returns all articles without FTS5 JOIN"
    - "Date range filtering restricts results to specified dates"
    - "Combined filters (search + date + status + blog) work together"
  artifacts:
    - path: "internal/storage/database.go"
      provides: "FTS5 migration, SearchArticles method"
      contains: "articles_fts"
    - path: "internal/model/model.go"
      provides: "SearchOptions struct"
      contains: "SearchOptions"
  key_links:
    - from: "internal/storage/database.go"
      to: "articles_fts"
      via: "ensureMigrations creates FTS5 table and triggers"
      pattern: "CREATE VIRTUAL TABLE.*articles_fts"
    - from: "internal/storage/database.go"
      to: "model.SearchOptions"
      via: "SearchArticles accepts options struct"
      pattern: "func.*SearchArticles.*SearchOptions"
---

<objective>
Create FTS5 full-text search infrastructure and flexible search query method for articles.

Purpose: Enable title search and date filtering at the database layer, providing the foundation for all Phase 7 UI features.
Output: FTS5 virtual table with sync triggers, SearchOptions struct, SearchArticles method returning articles with count.
</objective>

<execution_context>
@/Users/esteban.torres/.claude/get-shit-done/workflows/execute-plan.md
@/Users/esteban.torres/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-search-date-filtering/07-RESEARCH.md
@internal/storage/database.go
@internal/model/model.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FTS5 virtual table and sync triggers</name>
  <files>internal/storage/database.go</files>
  <action>
Extend ensureMigrations() to create FTS5 infrastructure:

1. Add check for articles_fts table existence (use sqlite_master query)
2. If FTS5 table does not exist, execute these SQL statements in order:
   a. Create FTS5 virtual table with external content pattern:
      ```sql
      CREATE VIRTUAL TABLE articles_fts USING fts5(
          title,
          content='articles',
          content_rowid='id'
      )
      ```
   b. Create INSERT trigger (articles_ai):
      ```sql
      CREATE TRIGGER articles_ai AFTER INSERT ON articles BEGIN
          INSERT INTO articles_fts(rowid, title) VALUES (new.id, new.title);
      END
      ```
   c. Create UPDATE trigger (articles_au) - DELETE old first, then INSERT new:
      ```sql
      CREATE TRIGGER articles_au AFTER UPDATE ON articles BEGIN
          INSERT INTO articles_fts(articles_fts, rowid, title) VALUES('delete', old.id, old.title);
          INSERT INTO articles_fts(rowid, title) VALUES (new.id, new.title);
      END
      ```
   d. Create DELETE trigger (articles_ad):
      ```sql
      CREATE TRIGGER articles_ad AFTER DELETE ON articles BEGIN
          INSERT INTO articles_fts(articles_fts, rowid, title) VALUES('delete', old.id, old.title);
      END
      ```
   e. Populate FTS5 from existing articles:
      ```sql
      INSERT INTO articles_fts(rowid, title) SELECT id, title FROM articles
      ```

3. Add helper function ftsTableExists(tableName string) bool using:
   ```sql
   SELECT name FROM sqlite_master WHERE type='table' AND name=?
   ```

IMPORTANT: FTS5 DELETE uses special INSERT syntax with 'delete' command, NOT standard DELETE.
IMPORTANT: UPDATE trigger must delete old entry BEFORE inserting new entry.
  </action>
  <verify>
Run the server and check logs for migration success:
```bash
cd /Users/esteban.torres/workspace/github/esttorhe/blogwatcher-ui && go build ./cmd/server && ./server 2>&1 | head -5
```
Then verify FTS5 table exists:
```bash
sqlite3 ~/.blogwatcher/blogwatcher.db "SELECT name FROM sqlite_master WHERE type='table' AND name='articles_fts'"
```
Expected: articles_fts
  </verify>
  <done>
FTS5 virtual table articles_fts exists with three sync triggers (articles_ai, articles_au, articles_ad). Existing articles are indexed. Server starts without migration errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SearchOptions struct and SearchArticles method</name>
  <files>internal/model/model.go, internal/storage/database.go</files>
  <action>
1. In internal/model/model.go, add SearchOptions struct:
   ```go
   // SearchOptions contains all filter parameters for article search.
   // All fields are optional - nil/empty means no filter for that field.
   type SearchOptions struct {
       SearchQuery string     // FTS5 search query (empty = skip FTS5)
       IsRead      *bool      // nil = all, true = read only, false = unread only
       BlogID      *int64     // nil = all blogs
       DateFrom    *time.Time // nil = no lower bound
       DateTo      *time.Time // nil = no upper bound
   }
   ```

2. In internal/storage/database.go, add SearchArticles method:
   ```go
   // SearchArticles returns articles matching the given search options with total count.
   // Uses FTS5 for title search when SearchQuery is non-empty.
   // Returns (articles, totalCount, error).
   func (db *Database) SearchArticles(opts model.SearchOptions) ([]model.ArticleWithBlog, int, error)
   ```

   Implementation details:
   a. Build base query selecting from articles a INNER JOIN blogs b
   b. If opts.SearchQuery is non-empty:
      - Add JOIN to articles_fts fts ON a.id = fts.rowid
      - Add condition: fts MATCH ?
      - Append search query to args
   c. Add status condition only if opts.IsRead is not nil
   d. Add blog condition only if opts.BlogID is not nil
   e. Add date conditions using COALESCE(a.published_date, a.discovered_date):
      - DateFrom: >= opts.DateFrom.Format("2006-01-02")
      - DateTo: < opts.DateTo.AddDate(0,0,1).Format("2006-01-02") (next day for inclusive end)
   f. Include COUNT(*) OVER() as total_count in SELECT
   g. ORDER BY a.discovered_date DESC

   Key patterns from research:
   - Use strings.Builder or slice for conditions
   - Use []interface{} for args
   - Conditionally add FTS5 JOIN only when search query present
   - Use parameterized queries (never string concat for values)
   - Parse total_count from first row, return 0 if no results
  </action>
  <verify>
Create a simple test in the same file or run manual verification:
```bash
cd /Users/esteban.torres/workspace/github/esttorhe/blogwatcher-ui && go build ./...
```
Then test search via sqlite3:
```bash
sqlite3 ~/.blogwatcher/blogwatcher.db "SELECT rowid, title FROM articles_fts WHERE articles_fts MATCH 'test' LIMIT 5"
```
  </verify>
  <done>
SearchOptions struct exists in model.go. SearchArticles method compiles, handles empty search (no FTS5 JOIN), handles all filter combinations, returns articles with total count.
  </done>
</task>

</tasks>

<verification>
1. Server starts without errors after FTS5 migration
2. FTS5 table and triggers exist in database:
   ```bash
   sqlite3 ~/.blogwatcher/blogwatcher.db ".schema articles_fts"
   sqlite3 ~/.blogwatcher/blogwatcher.db "SELECT name FROM sqlite_master WHERE type='trigger' AND name LIKE 'articles_a%'"
   ```
3. Go code compiles: `go build ./...`
4. Manual FTS5 query returns results: `sqlite3 ~/.blogwatcher/blogwatcher.db "SELECT * FROM articles_fts LIMIT 3"`
</verification>

<success_criteria>
- [ ] FTS5 virtual table articles_fts exists with content='articles', content_rowid='id'
- [ ] Three triggers exist: articles_ai, articles_au, articles_ad
- [ ] Existing articles are indexed in FTS5 table
- [ ] SearchOptions struct defined with all filter fields
- [ ] SearchArticles method handles: empty search, search query, status filter, blog filter, date range
- [ ] SearchArticles returns total count via window function
- [ ] All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-search-date-filtering/07-01-SUMMARY.md`
</output>
