---
phase: 01-infrastructure-setup
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/server/main.go
  - internal/server/server.go
  - internal/server/routes.go
  - internal/server/handlers.go
  - templates/base.gohtml
  - templates/pages/index.gohtml
  - templates/partials/article-list.gohtml
autonomous: true

must_haves:
  truths:
    - "User can navigate to localhost:8080 and see a page served by Go server"
    - "Page includes HTMX library loaded from /static/htmx.min.js"
    - "HTMX request to /articles returns HTML fragment (not full page)"
    - "Non-HTMX request to /articles returns full page with base layout"
    - "Server shuts down gracefully on SIGTERM/SIGINT"
  artifacts:
    - path: "cmd/server/main.go"
      provides: "Server entry point with graceful shutdown"
      min_lines: 25
    - path: "internal/server/server.go"
      provides: "NewServer constructor with dependency injection"
      exports: ["NewServer", "Server"]
    - path: "internal/server/routes.go"
      provides: "Route registrations"
      contains: "registerRoutes"
    - path: "internal/server/handlers.go"
      provides: "HTTP handlers"
      contains: "HX-Request"
    - path: "templates/base.gohtml"
      provides: "Base HTML layout"
      contains: "htmx.min.js"
    - path: "templates/pages/index.gohtml"
      provides: "Main page template"
    - path: "templates/partials/article-list.gohtml"
      provides: "Article list fragment for HTMX"
  key_links:
    - from: "cmd/server/main.go"
      to: "internal/server/server.go"
      via: "NewServer constructor call"
      pattern: "server\\.NewServer"
    - from: "internal/server/handlers.go"
      to: "templates/"
      via: "template.ExecuteTemplate"
      pattern: "ExecuteTemplate.*gohtml"
    - from: "templates/base.gohtml"
      to: "static/htmx.min.js"
      via: "script src attribute"
      pattern: "src=.*htmx\\.min\\.js"
---

<objective>
Create HTTP server with HTMX integration and template rendering.

Purpose: Build the web server that serves pages, handles HTMX requests, and provides the user-facing interface. This server will use the database layer from Plan 01, but the server structure itself can be built in parallel.

Output: Running HTTP server at localhost:8080 that serves pages with HTMX capability and detects HTMX requests for partial responses.
</objective>

<execution_context>
@/Users/esteban.torres/.claude/get-shit-done/workflows/execute-plan.md
@/Users/esteban.torres/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-setup/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create server package with NewServer pattern</name>
  <files>internal/server/server.go, internal/server/routes.go</files>
  <action>
    Create internal/server/server.go:
    - Add ABOUTME comment at top
    - Define Server struct with fields:
      - db *storage.Database (dependency injection)
      - templates *template.Template (parsed at startup)
      - mux *http.ServeMux
    - Implement NewServer(db *storage.Database) (http.Handler, error):
      - Parse templates once using template.ParseGlob("templates/**/*.gohtml")
      - Create ServeMux and register routes
      - Return Server (implements http.Handler via ServeHTTP)
    - Implement ServeHTTP(w, r) to delegate to mux
    - Import: github.com/esttorhe/blogwatcher-ui/internal/storage

    Create internal/server/routes.go:
    - Add ABOUTME comment at top
    - Implement registerRoutes(mux *http.ServeMux) method on Server:
      - GET /static/ - serve static files via http.FileServer
      - GET / - serve index page (handleIndex)
      - GET /articles - serve article list (handleArticleList)
      - GET /blogs - serve blog list (handleBlogList)
    - Use Go 1.22+ method routing: mux.HandleFunc("GET /path", handler)

    Do NOT add database-dependent logic yet - handlers will be stubbed with placeholder data for parallel development.
  </action>
  <verify>
    Run `go build ./internal/server/...` - should compile (may need stub storage import).
    Run `go vet ./internal/server/...` - should pass.
  </verify>
  <done>
    - Server struct defined with dependency injection pattern
    - NewServer constructor parses templates and registers routes
    - Routes defined for static files, index, articles, blogs
    - Code compiles and passes vet
  </done>
</task>

<task type="auto">
  <name>Task 2: Create handlers with HTMX detection</name>
  <files>internal/server/handlers.go</files>
  <action>
    Create internal/server/handlers.go:
    - Add ABOUTME comment at top
    - Implement helper method renderTemplate(w, name, data):
      - Executes named template with data
      - Logs errors and returns 500 on failure
    - Implement handleIndex(w, r):
      - Renders pages/index.gohtml with base layout
    - Implement handleArticleList(w, r):
      - Check HX-Request header: if r.Header.Get("HX-Request") == "true"
      - If HTMX: render partials/article-list.gohtml (fragment only)
      - If not HTMX: render pages/index.gohtml (full page)
      - For now, pass empty/placeholder article data (Plan 01 provides real data)
    - Implement handleBlogList(w, r):
      - Similar HTMX detection pattern
      - Render blog list partial or full page

    HTMX detection is critical for requirement INFRA-03. The HX-Request header indicates HTMX-initiated requests that expect HTML fragments, not full pages.
  </action>
  <verify>
    Run `go build ./internal/server/...` - should compile.
    Run `go vet ./internal/server/...` - should pass.
  </verify>
  <done>
    - Handlers detect HX-Request header for HTMX requests
    - HTMX requests return partial templates (fragments)
    - Non-HTMX requests return full page with base layout
    - Helper method for template rendering with error handling
  </done>
</task>

<task type="auto">
  <name>Task 3: Create templates and main entry point</name>
  <files>cmd/server/main.go, templates/base.gohtml, templates/pages/index.gohtml, templates/partials/article-list.gohtml</files>
  <action>
    Create templates/base.gohtml:
    - Standard HTML5 doctype and structure
    - Viewport meta for mobile responsiveness
    - Load HTMX: <script src="/static/htmx.min.js"></script>
    - Define "base" template with {{template "title" .}} and {{template "content" .}} blocks
    - Minimal styling placeholder (dark theme comes in Phase 2)

    Create templates/pages/index.gohtml:
    - Define "title" block: "BlogWatcher"
    - Define "content" block with basic structure:
      - Heading: BlogWatcher
      - Div with id="article-list" for HTMX target
      - hx-get="/articles" hx-trigger="load" to load articles on page load
      - Include placeholder text while loading

    Create templates/partials/article-list.gohtml:
    - Define partial that can be rendered standalone for HTMX
    - Loop through Articles with {{range .Articles}}
    - Show placeholder content: "Articles will appear here" when empty
    - Basic list structure (styled in Phase 2)

    Create cmd/server/main.go:
    - Add ABOUTME comment at top
    - Implement run(ctx context.Context) error function:
      - Open database (from storage package)
      - Create server with NewServer(db)
      - Configure http.Server with timeouts:
        - ReadTimeout: 5s
        - WriteTimeout: 10s
        - IdleTimeout: 120s
        - Addr: ":8080"
      - Start server in goroutine
      - Wait for ctx.Done() for graceful shutdown
      - Shutdown with 10s timeout
    - Implement main():
      - Create context with signal.NotifyContext for SIGINT, SIGTERM
      - Call run(ctx)
      - Log startup message: "Server starting on :8080"
      - Handle errors appropriately
  </action>
  <verify>
    Run `go build ./cmd/server/...` - should compile.
    Start server: `go run ./cmd/server &` then `sleep 2`.
    Test static file: `curl -s localhost:8080/static/htmx.min.js | head -c 100` - should return JS.
    Test full page: `curl -s localhost:8080/` - should return HTML with htmx.min.js script tag.
    Test HTMX request: `curl -s -H "HX-Request: true" localhost:8080/articles` - should return fragment (no DOCTYPE).
    Kill server gracefully: should log shutdown message.
  </verify>
  <done>
    - Templates render with base layout for full pages
    - HTMX library loaded in base template
    - Index page triggers HTMX load of articles on startup
    - Partial templates render without base layout for HTMX
    - Server starts on :8080 with proper timeouts
    - Server shuts down gracefully on signals
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Server starts: `go run ./cmd/server` shows startup message
2. Static files served: `curl localhost:8080/static/htmx.min.js` returns HTMX JS
3. Full page served: `curl localhost:8080/` returns HTML with DOCTYPE, htmx script tag
4. HTMX detection works:
   - `curl localhost:8080/articles` returns full page (DOCTYPE present)
   - `curl -H "HX-Request: true" localhost:8080/articles` returns fragment (no DOCTYPE)
5. Graceful shutdown: Send SIGTERM, server logs shutdown and exits cleanly
6. Code quality: `go vet ./...` passes
</verification>

<success_criteria>
- Server runs on localhost:8080
- Static file serving works for HTMX library
- Base template includes HTMX script
- Full page requests return complete HTML with base layout
- HTMX requests (HX-Request header) return HTML fragments only
- Server has proper timeouts (Read: 5s, Write: 10s, Idle: 120s)
- Graceful shutdown on SIGTERM/SIGINT with 10s drain period
- All code compiles and passes go vet
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-setup/01-02-SUMMARY.md`
</output>
